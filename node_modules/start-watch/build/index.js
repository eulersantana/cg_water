'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

const defaultEvents = ['add', 'change'];
const defaultOptions = { persistent: true };

exports.default = function (files) {
  let events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEvents;
  let userOptions = arguments[2];
  return callback => () => {
    if (!files || Array.isArray(files) && !files.length) {
      throw new Error('Need files to watch');
    }

    if (!callback || typeof callback !== 'function') {
      throw new Error('Need a callback function');
    }

    return function watch(log) {
      const chokidar = require('chokidar');

      const options = _extends({}, defaultOptions, userOptions);

      return new Promise((resolve, reject) => {
        const initialFiles = [];
        const initialListener = file => initialFiles.push(file);

        const watcher = chokidar.watch(files, options);

        watcher.once('error', reject);

        watcher.on('add', initialListener);
        watcher.once('ready', () => {
          watcher.removeListener('add', initialListener);

          const watchForChanges = () => {
            events.forEach(event => {
              watcher.once(event, file => {
                callback([file]).then(watchForChanges).catch(watchForChanges);
              });
            });
          };

          callback(initialFiles).then(watchForChanges).catch(watchForChanges).then(() => {
            log('watching for changes, press ctrl-c to exit');
          });
        });
      });
    };
  };
};